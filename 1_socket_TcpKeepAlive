事情是这么发生的。。。

有一天。。。
测试的兄弟过来找我，说DN之间无法通信了。。。让我定位。。。

DN1和DN2之间正常会有16个TCP连接，如果是作为server端则表示为rx，如果作为客户端则表示为tx。
即，正常的情况是两边对称的：
DN1     DN2
rx1<-----tx1
rx2<-----tx2
rx3<-----tx3
rx4<-----tx4
rx5<-----tx5
rx6<-----tx6
rx7<-----tx7
rx8<-----tx8
tx1------>rx1
tx2------>rx2
tx3------>rx3
tx4------>rx4
tx5------>rx5
tx6------>rx6
tx7------>rx7
tx8------>rx8

但是，测试兄弟的DN情况却不是对称的。。。DN1上面没有和DN2的连接，但是DN2上面又有8个来自DN1的连接。

复现方式嘛，就是他先拔掉了DN1和DN2之间的数据通道，然后过了一段时间后，把数据通道接通，DN1和DN2仍然不能通信。。。

OK。一步一步来。

1、首先，DN2上面有8个rx，如果再收到DN1发过来的链接，就会close掉，导致DN1上面一直没有tx。
2、为什么拔掉网线了，连接还在？很明显，没有数据交互的时候，拔网线，应用层感应不到的。
   通过开启TcpKeepAlive解决，即可在拔掉网线后关闭没有数据交互的链接。
3、为什么DN1上面的连接都关掉了？应用层是如何感知到的呢？猜测，是某一个write的结果为负数，那在拔网线的情况下还有什么会导致write的结果为负数呢？
   我们知道，write，只是把数据放到缓冲区即返回成功，而不在乎缓冲区什么时候发送出去。猜测，如果放到缓冲区失败，则会返回失败。什么时候会放到缓冲区失败呢？缓冲区写满了。。。
   
   
好的，我在tx和rx的socket中都打开了tcpkeepalive，且设置了时间和次数等三个参数，分别为“60,5,3”。然后再拔掉网线看看。

发现，有的链接可以关掉，而有的链接关不掉。而关不掉的链接，他们的定时器根本就没有倒计时。。。
通过netstat -o可以看到链接的定时器情况。通过netstat -anp可以看到链接的其他情况，比如发送队列和接收队列里面有多少数据。
然后发现，只要发送队列或者接收队列里面有数据，那tcpkeepalive定时器就不会生效。。。



不过呢，这个设定仍然不影响问题的解决。
开启TcpKeepAlive以后，假如DN2上面仍然有某个socket未关闭，那么肯定是发送队列里面有东西。
如果在恢复数据通道以后，他的发送队列里面还有数据，则发出去给DN1，DN1如果socket也没关，那很好，大家继续用。
                                                            DN1如果socket关闭了，那就发送rst给DN2，DN2收到，关闭socket。

